'''
Акобян К.А. ИС 1.1

Этот код создает простой сервер Socket.IO, который слушает подключения на порту 8000.

sid – это идентификатор пользователя, например Ix1RoDSgQ5BytHmFAAAB. 
Это строка, которая нужна, чтобы отличать одного пользователя от другого. Например, при рассылке сообщений.

environ – Это объект в котором передается информация о запросе. 
В нашем случае – о подключении. Это техническая информация о соединении и она не понадобится нам 
(по крайней мере до тех пор, пока вебсокеты работают нормально)
'''


import eventlet
import socketio
from datetime import datetime

'''
Создает экземпляр сервера Socket.IO с разрешенной корс-политикой (cors_allowed_origins='*'), 
что означает, что сервер позволяет подключения от всех источников.
CORS-политика (Cross-Origin Resource Sharing) — это механизм браузера, 
который ограничивает запросы к серверу с других доменов, 
протоколов или портов. По умолчанию браузер блокирует такие «кросс-доменные» запросы ради безопасности.
'''

sio = socketio.Server(cors_allowed_origins='*')

# Список для хранения идентификаторов подключенных клиентов
connected_clients = []

# Словарь для хранения времени подключения каждого клиента
# Ключ - идентификатор сокета (sid), значение - объект datetime с временем подключения
connection_times = {}

def get_server_status(count):
    """
    Функция для определения статуса сервера в зависимости от количества подключенных пользователей
    count: количество подключенных пользователей
    """
    if count == 0:
        return "Сервер пуст"
    elif count == 1:
        return "Пользователь один"
    else:  # count >= 2
        return "Команда в сборе"


'''
WSGI (Web Server Gateway Interface) — это стандартный протокол взаимодействия между Python-веб-приложением и веб-сервером. 
Он определяет, как сервер (например,Eventlet) вызывает Python-код, передаёт ему HTTP-запросы и получает ответы.

В контексте Socket.IO:
я создаю WSGI-совместимое приложение, которое объединяет обычный HTTP-сервер и Socket.IO-транспорт.

То есть WSGIApp:
    принимает HTTP-запросы (включая WebSocket-upgrade),
    мршрутизирует их в Socket.IO-сервер (`sio`),
    обеспечивает совместимость с любым WSGI-сервером (eventlet, gevent, gunicorn с воркерами WSGI).

Итог: это адаптер, который позволяет Socket.IO-серверу работать поверх стандартного питоновского веб-серверного интерфейса.
'''
app = socketio.WSGIApp(sio)

# Объект для учета количества запросов без обработчиков
lost_queries = {"count": 0}

# Словарь для хранения счетов пользователей
user_scores = {}

# Выводим начальный статус сервера
print(get_server_status(len(connected_clients)))


'''
Обработчик события подключения, используем для чтобы поприветствовать клиента, обновить счетчик посетителей на сайте, 
отправить информацию, которая пригодится при использовании сервера.

Декораторы в Python — это механизм, который позволяет оборачивать функции или методы другой функцией 
для изменения их поведения без изменения их исходного кода.

Это декоратор, потому что строка: @sio.event
оборачивает функцию `connect` в специальный обработчик событий Socket.IO.

Технически это работает так:
`sio.event` — это функция, которая принимает другую функцию.
Когда Python видит `@decorator`, он делает следующее: connect = sio.event(connect)

То есть функция передаётся методу `sio.event`, который:
регистрирует её как обработчик события `connect`;
возвращает обёрнутую функцию (или саму же), но уже привязанную к Socket.IO-серверу.

Таким образом, `@sio.event` — это декоратор, который автоматически 
регистрирует функцию как обработчик события Socket.IO, 
без необходимости вручную вызывать `sio.on('connect', connect)`.
'''
@sio.event # Декоратор
def connect(sid, environ):
    # Добавляем идентификатор соединения в список
    connected_clients.append(sid)
    
    # Выводим сообщение о подключении (для отладки)
    print(sid, "connected")
    
    # Записываем время подключения клиента в словарь
    # Ключ - идентификатор сокета (sid), значение - объект datetime с текущим временем
    connection_times[sid] = datetime.now()
    
    # Выводим сообщение о подключении клиента
    print(f"Клиент подключился!")
    
    # Выводим содержание списка подключенных клиентов
    print(connected_clients)
    
    # Выводим сообщение о подключении клиента с его ID
    print(f"Клиент {sid} подключился")
    
    # Выводим статус сервера в зависимости от количества подключенных пользователей
    print(get_server_status(len(connected_clients)))
    
    # Отправляем новому клиенту сообщение "Welcome to the server" при событии "message"
    sio.emit("message", {"text": "Welcome to the server"}, to=sid)
    
    # Отправляем обновленное количество пользователей всем подключенным клиентам
    sio.emit("message", {"online": len(connected_clients)})


'''
Обработчик события message, принимает и обрабатывает сообщения от клиента.
'''
@sio.on("message")
def handle_message(sid, data):
    # Отправляем сообщение всем подключенным пользователям, кроме отправителя
    sio.emit("message", data, skip_sid=sid)


'''
Обработчик события get_users_online, возвращает количество пользователей онлайн.
'''
@sio.on("get_users_online")
def handle_get_users_online(sid, data):
    # Отправляем количество пользователей онлайн
    sio.emit("users", {"online": len(connection_times)}, room=sid)


'''
Обработчик события count_queries, возвращает количество потерянных запросов.
'''
@sio.on("count_queries")
def handle_count_queries(sid, data):
    # Отправляем количество потерянных запросов
    sio.emit("queries", {"lost": lost_queries["count"]}, room=sid)

'''
Обработчик события increase, увеличивает счет пользователя на 1.
'''
@sio.on("increase")
def handle_increase(sid, data):
    # Увеличиваем счет пользователя на 1
    if sid in user_scores:
        user_scores[sid] += 1
    else:
        user_scores[sid] = 1


'''
Обработчик события decrease, уменьшает счет пользователя на 1.
'''
@sio.on("decrease")
def handle_decrease(sid, data):
    # Уменьшаем счет пользователя на 1
    if sid in user_scores:
        user_scores[sid] -= 1
    else:
        user_scores[sid] = -1


'''
Обработчик события get_score, возвращает текущий счет пользователя.
'''
@sio.on("get_score")
def handle_get_score(sid, data):
    # Отправляем счет пользователя
    score = user_scores.get(sid, 0)
    sio.emit("score", {"score": score}, room=sid)


'''
Универсальный обработчик событий, обрабатывает все события, для которых нет специфических обработчиков.
Увеличивает счетчик потерянных запросов и отправляет сообщение об ошибке клиенту.
'''
@sio.on('*')
def catch_all(event, sid, data):
    # Увеличиваем счетчик запросов без обработчиков
    lost_queries["count"] += 1
    # Отправляем сообщение об ошибке только если событие не является системным
    if event not in ["connect", "disconnect"]:
        sio.emit("error", {"message": f"No handler for event {event}"}, room=sid)


'''
Для обработки отключения мы используем декоратор sio.event и функцию disconnect.
При отключении можно уменьшить счетчик пользователей, сообщить другим клиентам, что пользователь потерялся. 
Событие disconnect срабатывает и тогда, когда пользователь отправил фрейм CLOSE, и когда сежду клиентом и сервером пропала связь. 
Если соединение не было закрыто пользователем, после восстановления связи клиент попробует восстановить соединение.
'''
@sio.event # Декоратор
def disconnect(sid):
    # Удаляем идентификатор из списка подключенных клиентов
    if sid in connected_clients:
        connected_clients.remove(sid)
    
    # Выводим сообщение об отключении клиента
    print("Клиент отключился")
    
    # Выводим содержание списка подключенных клиентов
    print(connected_clients)
    
    # Получаем время подключения клиента
    connect_time = connection_times[sid]
    
    # Удаляем запись о клиенте из словаря
    del connection_times[sid]
    
    # Вычисляем продолжительность сессии
    session_duration = datetime.now() - connect_time
    
    # Выводим сообщение об отключении клиента и продолжительность его сессии
    print(f"Клиент {sid} отключился, время сессии: {session_duration}")
    
    # Выводим статус сервера после отключения клиента
    print(get_server_status(len(connected_clients)))
    
    # Отправляем обновленное количество пользователей всем оставшимся подключенным клиентам
    sio.emit("message", {"online": len(connected_clients)})

# Запускает eventlet WSGI сервер, слушая подключения на порту 8000 и используя ранее созданное приложение app.
eventlet.wsgi.server(eventlet.listen(('', 8000)), app)
