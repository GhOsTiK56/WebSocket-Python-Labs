'''
Акобян К.А. ИС 1.1

Этот код создает простой сервер Socket.IO, который слушает подключения на порту 8000.

sid – это идентификатор пользователя, например Ix1RoDSgQ5BytHmFAAAB. 
Это строка, которая нужна, чтобы отличать одного пользователя от другого. Например, при рассылке сообщений.

environ – Это объект в котором передается информация о запросе. 
В нашем случае – о подключении. Это техническая информация о соединении и она не понадобится нам 
(по крайней мере до тех пор, пока вебсокеты работают нормально)
'''
import eventlet
import socketio

# Создает экземпляр сервера Socket.IO с разрешенной корс-политикой (cors_allowed_origins='*'), 
# что означает, что сервер позволяет подключения от всех источников.
sio = socketio.Server(cors_allowed_origins='*')

# Список для хранения идентификаторов подключенных пользователей
connected_users = set()

# Создает WSGI (Web Server Gateway Interface) приложение и связывает его с экземпляром сервера Socket.IO.
app = socketio.WSGIApp(sio)

# Объект для учета количества запросов без обработчиков
lost_queries = {"count": 0}


'''
Обработчик события подключения, используем для чтобы поприветствовать клиента, обновить счетчик посетителей на сайте, 
отправить информацию, которая пригодится при использовании сервера.
'''

@sio.event # Декоратор
def connect(sid, environ):
    print(f"Клиент {sid} подключен")
    # Добавляем идентификатор подключившегося пользователя в список
    connected_users.add(sid)


'''

'''

@sio.on("message")
def incoming_message(sid, data):
    print("мне сказали", data, sid)


'''

'''

# Обработчик события get_users_online
@sio.on("get_users_online")
def handle_get_users_online(sid, data):
    # Отправляем количество пользователей онлайн
    sio.emit("users", {"online": len(connected_users)}, room=sid)


'''

'''

# Обработчик события count_queries
@sio.on("count_queries")
def handle_count_queries(sid, data):
    # Отправляем количество потерянных запросов
    sio.emit("queries", {"lost": lost_queries["count"]}, room=sid)








'''

'''
# Универсальный обработчик событий
@sio.on('*')
def catch_all(event, sid, data):
    # Увеличиваем счетчик запросов без обработчиков
    lost_queries["count"] += 1
    # Отправляем сообщение об ошибке только если событие не является системным
    if event not in ["connect", "disconnect"]:
        sio.emit("error", {"message": f"No handler for event {event}"}, room=sid)


'''
Для обработки отключения мы используем декоратор sio.event и функцию disconnect.
При отключении можно уменьшить счетчик пользователей, сообщить другим клиентам, что пользователь потерялся. 
Событие disconnect срабатывает и тогда, когда пользователь отправил фрейм CLOSE, и когда сежду клиентом и сервером пропала связь. 
Если соединение не было закрыто пользователем, после восстановления связи клиент попробует восстановить соединение.
'''
# Обработчик события отключения
@sio.event # Декоратор
def disconnect(sid):
    print(f"Клиент {sid} отключен")
    # Удаляем идентификатор отключившегося пользователя из списка
    connected_users.discard(sid)










# Запускает eventlet WSGI сервер, слушая подключения на порту 80 и используя ранее созданное приложение app.
eventlet.wsgi.server(eventlet.listen(('', 8000)), app)